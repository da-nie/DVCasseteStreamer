#ifndef C_DV_VAUX_H
#define C_DV_VAUX_H

//====================================================================================================
//класс работы с секцией vaux для dv-формата
//====================================================================================================

//====================================================================================================
//подключаемые библиотеки
//====================================================================================================

#include <stdint.h>
#include <stdio.h>

#include "cdvdifid.h"
#include "cdateymdcode.h"
#include "cdatehmscode.h"

//====================================================================================================
//класс работы с секцией vaux для dv-формата
//====================================================================================================
class CDVVAUX
{
 public:
  //-Перечисления---------------------------------------------------------------------------------------
  //значения идентификатора
  enum VAUX_ID_VALUE
  {
   VAUX_ID_VS=0x60,
   VAUX_ID_VSC=0x61
  };

  //значения CLF
  enum CLF_VALUE
  {
   CLF_NTSC_A=0,
   CLF_NTSC_B=1,

   CLF_PAL_1_2_FIELD=0,
   CLF_PAL_3_4_FIELD=1,
   CLF_PAL_5_6_FIELD=2,
   CLF_PAL_7_8_FIELD=3
  };
  //значения STYPE
  enum STYPE_VALUE
  {
   STYPE_4_1_1_COMPRESSION=0,
   STYPE_4_2_2_COMPRESSION=4
  };
  //значения VISC
  enum VISC_VALUE
  {
   VISC_MINUS_180=(1<<7)|(1<<3),
   VISC_PLUS_180=(1<<6)|(1<<5)|(1<<4)|(1<<3),
   VISC_NO_INFO=(1<<6)|(1<<5)|(1<<4)|(1<<3)|(1<<2)|(1<<1)|(1<<0)
  };
  //значения DISP
  enum DISP_VALUE
  {
   DISP_4_3=0,
   DISP_16_9=2
  };
  //значения разрешений на копирование
  enum CGMS_VALUE
  {
   CGMS_COPY_FREE=0x00
  };
  //значения частоты кадров
  enum F50_60_VALUE
  {
   F50=0x01,
   F60=0x00
  };
  //значения наличия черезстрочной развёртки
  enum IL_VALUE
  {
   IL_NO_INTERLACE=0x00,
   IL_INTERLACE=0x01   
  };
  //значения разрешения на использование данных CLF
  enum EN_VALUE
  {
   EN_CLF_IS_INVALID=0x01,
   EN_CLF_IS_VALID=0x00
  };
  //значение цветное или чёрно-белое изображение
  enum BW_VALUE
  {
   BW_BLACK_AND_WHITE=0x00,
   BW_COLOR=0x01
  };
  //значения изменился ли кадр
  enum FC_VALUE
  {
   FC_SAME_PREVIOUS_FRAME=0x0,
   FC_DIFFERENT_PREVIOUS_FRAME=0x01
  };
  //первый/второй полукадр
  enum FS_VALUE
  {
   FS_FIELD_2=0x00,
   FS_FIELD_1=0x01
  };
  //значение кадр/поле (повторяются ли полукадры)
  enum FF_VALUE
  {
   FF_TWICE=0x00,
   FF_NO_TWICE=0x01
  };

  //-Структуры------------------------------------------------------------------------------------------
  //биты внутри байта структуры заполняются от младшего к старшему! В документации они приведены наоборот!
  #pragma pack(1) 
  //блок VS (VS - vaux source pack)
  struct SVAUXVS
  { 
   //байт 0
   uint8_t ID;//идентификатор
   //байт 1
   uint8_t Res1;//зарезервировано (все биты 1)
   //байт 2
   uint8_t Res2:4;//зарезервировано (все биты 1)
   uint8_t CLF:2;//идентификационный код цветного кадра
   uint8_t EN:1;//используется ли CLF
   uint8_t BW:1;//цветное/чёрно-белое
   //байт 3
   uint8_t STYPE:5;//тип видеосигнала
   uint8_t F50_60:1;//50 (1)/60 (0) кадров в секунду
   uint8_t Res3:2;
   //байт 4
   uint8_t VISC;
  };
  //блок VSC (VSC - vaux source control pack)
  struct SVAUXVSC
  { 
   //байт 0
   uint8_t ID;//идентификатор
   //байт 1
   uint8_t Res1:6;//зарезервировано (все биты в 1)
   uint8_t CGMS:2;//система копирования
   //байт 2
   uint8_t DISP:3;//режим экрана
   uint8_t Res2:1;//зарезервировано (все биты в 1)
   uint8_t Zero1:2;//ноль
   uint8_t Res3:2;//зарезервировано (все биты в 1)
   //байт 3
   uint8_t Zero2:2;//ноль
   uint8_t Res4:2;//зарезервировано (все биты в 1)
   uint8_t IL:1;//0-нет черезстрочной развёртки, 1-есть черезстрочная развёртка
   uint8_t FC:1;//0-кадр такой же, как и предыдущий, 1-кадр другой
   uint8_t FS:1;//первое (0)/второе (1) поле кадра
   uint8_t FF:1;//1-два последовательных поля, 0- одно поле повторяется дважды
   //байт 4
   uint8_t Res5;//зарезервировано (все биты в 1)  
  };
  //пакеты DIF-блока VAUX
  union UVAUXPayload
  {
   SVAUXVS sVAUXVS;
   SVAUXVSC sVAUXVSC;
   uint8_t Data[5];
  }; 
  //DIF-блок
  struct SVAUXDIF
  {
   CDVDIFID::SDIFID sDIFID;//идентификатор DIF-блока
   UVAUXPayload uVAUXPayload[15];//данные
   uint8_t ReservedArray[2];//зарезервировано
  };
  //VAUX-блок
  struct SVAUX
  {
   SVAUXDIF sVAUXDIF[3];//в секции три DIF-блока
  };
  #pragma pack()
 private:
  //-Переменные-----------------------------------------------------------------------------------------  
  CDateYMDCode cDateYMDCode;
  CDateHMSCode cDateHMSCode;
  CDVDIFID cDVDIFID;
 public:
  //-Конструктор класса---------------------------------------------------------------------------------
  CDVVAUX(void);
  //-Деструктор класса----------------------------------------------------------------------------------
  ~CDVVAUX();
 public:
  //-Открытые функции класса----------------------------------------------------------------------------
  void Set(SVAUX *sVAUX_Ptr,uint8_t dif_sequence,const CDVTime &cDVTime_Current,bool is_pal);//задать секцию VAUX
  void OutputToFile(FILE *file,const std::string &prefix,SVAUX *sVAUX_Ptr);//вывести в файл параметры секции
  static uint32_t GetSectionSize(void);//получить размер секции в байтах
  //-Закрытые функции класса----------------------------------------------------------------------------
};

#endif
